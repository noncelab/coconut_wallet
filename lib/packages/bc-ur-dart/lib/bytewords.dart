import 'dart:typed_data';
import 'package:ur/utils.dart';
import 'package:collection/collection.dart';

const String BYTEWORDS =
    'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';

List<int>? _wordArray;

enum Style {
  standard,
  uri,
  minimal,
}

int decodeWord(String word, int wordLen) {
  if (word.length != wordLen) {
    throw ArgumentError('Invalid Bytewords.');
  }

  const int dim = 26;

  // Since the first and last letters of each Byteword are unique,
  // we can use them as indexes into a two-dimensional lookup table.
  // This table is generated lazily.
  if (_wordArray == null) {
    _wordArray = List.generate(dim * dim, (i) => -1);

    for (int i = 0; i < 256; i++) {
      int bytewordOffset = i * 4;
      int x = BYTEWORDS[bytewordOffset].codeUnitAt(0) - 'a'.codeUnitAt(0);
      int y = BYTEWORDS[bytewordOffset + 3].codeUnitAt(0) - 'a'.codeUnitAt(0);
      int arrayOffset = y * dim + x;
      _wordArray![arrayOffset] = i;
    }
  }

  // If the coordinates generated by the first and last letters are out of bounds,
  // or the lookup table contains -1 at the coordinates, then the word is not valid.
  int x = word[0].toLowerCase().codeUnitAt(0) - 'a'.codeUnitAt(0);
  int y = word[wordLen == 4 ? 3 : 1].toLowerCase().codeUnitAt(0) - 'a'.codeUnitAt(0);
  if (x < 0 || x >= dim || y < 0 || y >= dim) {
    throw ArgumentError('Invalid Bytewords.');
  }

  int value = _wordArray![y * dim + x];
  if (value == -1) {
    throw ArgumentError('Invalid Bytewords.');
  }

  // If we're decoding a full four-letter word, verify that the two middle letters are correct.
  if (wordLen == 4) {
    int bytewordOffset = value * 4;
    String c1 = word[1].toLowerCase();
    String c2 = word[2].toLowerCase();
    if (c1 != BYTEWORDS[bytewordOffset + 1] || c2 != BYTEWORDS[bytewordOffset + 2]) {
      throw ArgumentError('Invalid Bytewords.');
    }
  }

  // Successful decode.
  return value;
}

String getWord(int index) {
  int bytewordOffset = index * 4;
  return BYTEWORDS.substring(bytewordOffset, bytewordOffset + 4);
}

String getMinimalWord(int index) {
  int bytewordOffset = index * 4;
  return BYTEWORDS[bytewordOffset] + BYTEWORDS[bytewordOffset + 3];
}

String encode(Uint8List buf, String separator) {
  return buf.map((byte) => getWord(byte)).join(separator);
}

Uint8List addCrc(Uint8List buf) {
  Uint8List crcBuf = crc32Bytes(buf);
  return Uint8List.fromList([...buf, ...crcBuf]);
}

String encodeWithSeparator(Uint8List buf, String separator) {
  Uint8List crcBuf = addCrc(buf);
  return encode(crcBuf, separator);
}

String encodeMinimal(Uint8List buf) {
  Uint8List crcBuf = addCrc(buf);
  return crcBuf.map((byte) => getMinimalWord(byte)).join();
}

Uint8List decode(String s, String separator, int wordLen) {
  List<String> words;
  if (wordLen == 4) {
    words = s.split(separator);
  } else {
    words = partition(s, 2);
  }

  Uint8List buf = Uint8List(words.length);
  for (int i = 0; i < words.length; i++) {
    buf[i] = decodeWord(words[i], wordLen);
  }

  if (buf.length < 5) {
    throw ArgumentError('Invalid Bytewords.');
  }

  // Validate checksum
  Uint8List body = buf.sublist(0, buf.length - 4);
  Uint8List bodyChecksum = buf.sublist(buf.length - 4);
  Uint8List checksum = crc32Bytes(body);
  Function listEquals = const ListEquality().equals;
  if (!listEquals(checksum, bodyChecksum)) {
    throw ArgumentError('Invalid Bytewords.');
  }

  return body;
}

String encodeStyle(Style style, Uint8List bytes) {
  switch (style) {
    case Style.standard:
      return encodeWithSeparator(bytes, ' ');
    case Style.uri:
      return encodeWithSeparator(bytes, '-');
    case Style.minimal:
      return encodeMinimal(bytes);
    default:
      throw ArgumentError('Invalid Bytewords style.');
  }
}

Uint8List decodeStyle(Style style, String str) {
  switch (style) {
    case Style.standard:
      return decode(str, ' ', 4);
    case Style.uri:
      return decode(str, '-', 4);
    case Style.minimal:
      return decode(str, '', 2);
    default:
      throw ArgumentError('Invalid Bytewords style.');
  }
}
